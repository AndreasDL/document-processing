<?xml version="1.0" encoding="utf-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:msxsl="urn:schemas-microsoft-com:xslt" exclude-result-prefixes="msxsl">
    <xsl:output method="xml" indent="yes"/>
    
  <!-- Define the seperator values, which will be used to put and retrieve all the needed value in a string -->
    <xsl:variable name="seperator1" select="'('"/>
    <xsl:variable name="seperator2" select="')'"/>
    <!-- Default copy constructor generated by visual studio-->
    <xsl:template match="@* | node()">
        <xsl:copy>
            <xsl:apply-templates select="@* | node()"/>
        </xsl:copy>
    </xsl:template>

  <xsl:template match="paragraph">
    <paragraph>
      <xsl:apply-templates select="@*"/>
      <!-- let's call the function that will recursively define the shortest path-->
      <xsl:call-template name="find_shortest_path">
        <xsl:with-param name="branches" select="./branches"/>
        <xsl:with-param name="content" select="./content"/>
        <xsl:with-param name="current_branch_index" select="1"/>
        <xsl:with-param name="current_shortest_path" select="concat($seperator1,0,$seperator2,0,$seperator2,-1,$seperator1)"/>
      </xsl:call-template>
    </paragraph>
  </xsl:template>
  
  
  <xsl:template name="find_shortest_path">
    <!-- the format is ('vertex_number_1')'distance_1')'previous_node_1'('vertex_number_2')'distance_2')'previous_node_2'(....-->
    <xsl:param name="current_shortest_path"/>
    <!-- all the branches -->
    <xsl:param name="branches"/>
    <!-- the content of the paragraph -->
    <xsl:param name="content"/>
    <!-- the index of the branch we will use in this iteration-->
    <xsl:param name="current_branch_index"/>


    
    <xsl:choose>
      <!-- If not yet all branches are inspected, keep continuing -->
      <xsl:when test="$current_branch_index &lt;= count($branches/*)">
        <!-- first get the branch at the given index-->
        <xsl:variable name="current_branch" select="$branches/*[$current_branch_index]"/>
        <!-- get the current lowest cost for the 'previous' node -->
        <xsl:variable name="cost_previous" select="substring-before(substring-after($current_shortest_path,concat($seperator1,$current_branch/@previous,$seperator2)),$seperator2)"/>
        <!-- get the current lowest cost for the 'current' node -->
        <xsl:variable name="cost_end" select="substring-before(substring-after($current_shortest_path,concat($seperator1,$current_branch/@end,$seperator2)),$seperator2)"/>
        
        <!-- calculate the new cost to the end node starting from the previous node-->
        <xsl:variable name="new_cost">
          <xsl:choose>
            <xsl:when test="$current_branch/@cost='-INF'">
              <xsl:value-of select="$cost_previous"/>
            </xsl:when>
            <xsl:otherwise>
              <xsl:value-of select="$cost_previous + $current_branch/@cost"/>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:variable>

        <!-- set the new shortest path-->

        <xsl:variable name="new_shortest_path">
          <xsl:choose>
            <!--Add the new lowest cost for the 'end' node and its predescessor if necessary <-->
            <xsl:when test="not($cost_end) and $cost_previous">
              <xsl:value-of select="concat($current_shortest_path,$current_branch/@end,$seperator2,$new_cost,$seperator2,$current_branch_index,$seperator1)"/>
            </xsl:when>
            <!-- Update the new lowest cost for the 'end' node and its predescessor if necessary -->
            <xsl:when test="($new_cost &lt; $cost_end) and $cost_previous">
              <xsl:variable name="string_before" select="substring-before($current_shortest_path,concat($seperator1,$current_branch/@end,$seperator2))"/>
              <xsl:variable name="string_after" select="substring-after(substring-after($current_shortest_path,concat($seperator1,$current_branch/@end,$seperator2)),$seperator1)"/>
              <xsl:variable name="new_part" select="concat($seperator1,$current_branch/@end,$seperator2,$new_cost,$seperator2,$current_branch_index,$seperator1)"/>

              <xsl:value-of select="concat($string_before,$new_part,$string_after)"/>
            </xsl:when>
            <xsl:otherwise>
              <xsl:value-of select="$current_shortest_path"/>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:variable>
        
        
        <!-- get the next branch and restart the recursion -->
        <xsl:call-template name="find_shortest_path">
          <xsl:with-param name="current_shortest_path" select="$new_shortest_path"/>
          <xsl:with-param name="branches" select="$branches"/>
          <xsl:with-param name="content" select="$content"/>
          <xsl:with-param name="current_branch_index" select="$current_branch_index+1"/>
        </xsl:call-template>
      </xsl:when>
      <!-- If we reached the last branch, we will stop the iteration and get the final shortest path-->
      <xsl:otherwise>
        <xsl:call-template name="get_output_lines">
          <xsl:with-param name="shortest_path" select="$current_shortest_path"/>
          <xsl:with-param name="branches" select="$branches"/>
          <xsl:with-param name="content" select="$content"/>
          <xsl:with-param name="current_break_index" select="count($content/*)"/>
        </xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
    
    
    
  </xsl:template>

  <xsl:template name="get_output_lines">
    <!-- the format is ('vertex_number_1')'distance_1')'previous_node_1'('vertex_number_2')'distance_2')'previous_node_2'(....-->
    <xsl:param name="shortest_path"/>
    <!--  all the branches  -->
    <xsl:param name="branches"/>
    <!--  all the content  -->
    <xsl:param name="content"/>
    
    <!--the index of the break we will use in this iteration-->
    <xsl:param name="current_break_index"/>
    
    <xsl:variable name="current_break_info" select="substring-before(substring-after($shortest_path,concat($seperator1,$current_break_index,$seperator2)),$seperator1)"/>
    <xsl:variable name="current_branch_index" select="substring-after($current_break_info,$seperator2)"/>
    <xsl:if test="not($current_branch_index = -1)">
      <!--  first get the branch at the given index -->
      <xsl:variable name="current_branch" select="$branches/*[number($current_branch_index)]"/>
      
      <xsl:call-template name="get_output_lines">
        <xsl:with-param name="shortest_path" select="$shortest_path"/>
        <xsl:with-param name="branches" select="$branches"/>
        <xsl:with-param name="content" select="$content"/>
        <xsl:with-param name="current_break_index" select="$current_branch/@previous"/>
      </xsl:call-template>
      
      <line>
        <xsl:attribute name="ratio">
          <xsl:value-of select="$current_branch/@ratio"/>
        </xsl:attribute>

        <xsl:for-each select="$content/*[position() &gt;= $current_branch/@start and position() &lt;= $current_branch/@end]">
          <xsl:copy>
            <!-- copy the attributes and content-->
            <xsl:apply-templates select="@* | node()"/>
          </xsl:copy>
        </xsl:for-each>
        
      </line>
      
    </xsl:if>
  </xsl:template>
</xsl:stylesheet>
